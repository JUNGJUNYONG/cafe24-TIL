[TOC]

------

# ch04 분산을 고려한 MySQL 운용 



------

## [ 분산된 시스템 알기 ]

> 애플리케이션을 만들기 전에 알아두어야 할 MySQL 분산 노하우



#### < 지금까지의 주된 흐름 >

**분산을 할 때 고려할 것** 

- 국소성
- 데이터 규모에 맞는 탑재 메모리 조정
- 메모리 증설로도 대응할 수 없을 경우 분산



#### < 4장에서 다룰 것 >

- 분산을 고려한 MySQL 운용

- MySQL 스케일아웃 전략

  - 인덱스의 중요성(11강)
  - MySQL 분산(12강)
  - 스케일아웃과 파티셔닝(13강)

  > MySQL = LAMP[^Linux + Apache + MySQL + Perl]인 웹 서비스의 사실상 표준 데이터 저장소



#### < 들어가기 전 ... >

MySQL을 대규모 환경에서 운용할 때 어떤 점에 주의해야 하는지,

MySQL을 대규모 환경에서 운용할 경우의 분위기를 알아두는 것을 목표 !

------







------

## [ 강의 11, 인덱스를 올바르게 운용하기 ]

> 분산을 고려한 MySQL 운용의 대전제



### - 분산을 고려한 MySQL 운용, 세 가지 포인트

- OS 캐시 활용[^강의11]

- 인덱스를 적절하게 설정하기[^강의11]

  > Q : 인덱스를 생성하고 이를 사용하도록 제대로 쿼리를 던지면 응답이 빨라지는가!?
  >
  > A : 그렇다. 인덱스를 적절하게 설정하는 것은 매우 중요하다. 테이블의 칼럼에 인덱스를 생성하고, 해당 인덱스를 이용해 데이터를 검색할 수 있게되면 빨라진다.

- 확장을 전제로 한 설계[^강의12]



### - OS 캐시 활용

**OS 캐시**

> **전체 데이터 크기에 주의**해서 **데이터량이 물리 메모리보다 가능한 적어지도록 유지**한다.

> **메모리가 부족할 경우에는 증설**한다 (증설 포인트는 앞서 설명함)



**[ 스키마 설계가 데이터 크기에 미치는 영향을 고려한다. ]**

MySQL에서는 처음에 `create table`로 스키마를 결정 ! 

> 이 스키마는 상당히 중요함

앞서 설명했던 하테나 북마크의 경우와 같이 레코드 수가 3억이라면, 

1레코드에 8byte 칼럼을 1개 추가하면, ' 8*3억 byte(3GB) ' 만큼의 데이터가 늘어남

> 스키마를 조금 변경하는 것 만으로 GB단위로 데이터가 증감함

> 어느정도 규모 있는 서비스가 되면 칼럼변경, 스키마변경에도 주의를 기울여야 함



**대량의 데이터를 저장하려는 테이블은 레코드가 가능 한 작아지도록 간결하게 설계하도록!**

< 기본적인 수치는 머리에 새겨두자 >

> 정수(int형)는 32bit == 4byte
>
> 문자열은	       8bit == 1byte



### - 보충[정규화]

**Q : 정규화해서 DB를 나눠도 괜찮을까?**

> A : 정규화를 하면 좋다. 다만, 경우에따라 쿼리가 복잡해져 속도가 떨어지는 경우가 있으므로 데이터 크기 간 상반관계와 같은 부분도 생각해야함



### - 인덱스의 중요성 -B트리

**인덱스** 

> 탐색을 빠르게 하기 위한 것으로 내부 데이터 구조는 트리



**MySQL - B+트리**

- B+트리는 B트리에서 파생된 데이터 구조
- B트리는 트리를 구성하는 각 노드가 여러 개의 자식을 가질 수 있는 **다분트리**
- 데이터 삽입/삭제시 치우침이 생기지 않는 **평형트리**
- B트리는 하드디스크상 구축하기 알맞은 구조이므로 DB에서 자주 사용됨

> B트리에 의해 어떻게 탐색이 빨라지는가? **O(log n)**
>
> - B트리는 데이터 삽입 시 일정 규칙에 따라 삽입
> - 그 규칙으로 검색할 때 최소한의 순회로 데이터에 도달 가능!
>
> 세세한 이야기는 [참고](<https://potatoggg.tistory.com/174>)



**이분트리와 B트리 비교**

| ---      | 이분트리 | B트리                      |
| -------- | -------- | -------------------------- |
| 노드자식 | 2개      | 2개이상<br>노드수 `m=몇개` |

- 노드 자식이 반드시 2개

> **이분트리**는 부모노드가 반드시 1개, 자식 노드가 반드시 2개인 반면,
>
> **B트리**는 `m=5`와 같이 개수가 주어짐 
>
> - 개수를 조정함으로써 각각 노드의 크기를 지정할 수 있음
> - 디스크에 블록단위로 저장(캐싱)할 수 있음 -> 탐색시간이 줄어듦
>
> **B+트리**는 각 노드 내에 자식 노드로의 포인터만 가지고 있고, 실제 값은 마지막 노드(leaf node)만 가짐
>
> - **외부기억장치 탐색 시 Seek 횟수 최소화**
> - DB에 데이터 저장시 가장 최적화된 데이터 구조



**MySQL에서 인덱스(색인) 만들기**

- MySQL에서 인덱스를 만들면 B+트리 데이터 구조가 생김 -> O(log n) 보장

- DB탐색에서는 당연히 선형탐색보다 트리 순회가 더 빠름!



### - 인덱스의 효과

인덱스 효과는?

```
예) 4,000만건 테이블 탐색시
인덱스 X 선형 탐색 : O(n) : 최대 4,000만번 탐색
인덱스 O 이분 탐색 : O(log n) : 최대 25.25번 탐색
=> 디스크 구조에 최적화된 인덱스를 사용함으로 디스크 Seek 횟수에서도 차이가 남
	같은 O(log n)이여도 B트리와 다른 트리간에 서로 다름
```

> **엄청난 차이!!!!!!!!!!!!!!!!!!!!!!!!!!!!**



**인덱스 효과의 예**

데이터 크기가 커지면 인덱스 없이 시작부터 엑세스 할 수 없기에 인덱스가 매우 중요함!

> 1,000건 정도의 적은 데이터라면, 오히려 트리를 먼저 순회하는 오버헤드가 크기에 안쓰는게 나을수도
>
> 

















